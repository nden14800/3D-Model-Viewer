<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dモデルビューア</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS: スタイル設定 */
        :root {
            --bg-color-light: #f0f0f0;
            --text-color-light: #212121;
            --ui-bg-color-light: rgba(255, 255, 255, 0.85);
            --border-color-light: #cccccc;
            --button-bg-light: #e0e0e0;
            --button-hover-bg-light: #d5d5d5;
            --delete-button-bg-light: #d32f2f;
            --delete-button-hover-bg-light: #c62828;
            --scrollbar-thumb-light: #b0b0b0;
            --scrollbar-track-light: #e0e0e0;

            --bg-color-dark: #121212;
            --text-color-dark: #e0e0e0;
            --ui-bg-color-dark: rgba(40, 40, 40, 0.85);
            --border-color-dark: #444444;
            --button-bg-dark: #333333;
            --button-hover-bg-dark: #454545;
            --delete-button-bg-dark: #d32f2f;
            --delete-button-hover-bg-dark: #c62828;
            --scrollbar-thumb-dark: #555;
            --scrollbar-track-dark: #333;

            --accent-color: #03a9f4;
        }

        /* デフォルトはライトモード */
        body {
            --bg-color: var(--bg-color-light);
            --text-color: var(--text-color-light);
            --ui-bg-color: var(--ui-bg-color-light);
            --border-color: var(--border-color-light);
            --button-bg: var(--button-bg-light);
            --button-hover-bg: var(--button-hover-bg-light);
            --delete-button-bg: var(--delete-button-bg-light);
            --delete-button-hover-bg: var(--delete-button-hover-bg-light);
            --scrollbar-thumb: var(--scrollbar-thumb-light);
            --scrollbar-track: var(--scrollbar-track-light);
        }

        /* ダークモード設定を検知 */
        @media (prefers-color-scheme: dark) {
            body {
                --bg-color: var(--bg-color-dark);
                --text-color: var(--text-color-dark);
                --ui-bg-color: var(--ui-bg-color-dark);
                --border-color: var(--border-color-dark);
                --button-bg: var(--button-bg-dark);
                --button-hover-bg: var(--button-hover-bg-dark);
                --delete-button-bg: var(--delete-button-bg-dark);
                --delete-button-hover-bg: var(--delete-button-hover-bg-dark);
                --scrollbar-thumb: var(--scrollbar-thumb-dark);
                --scrollbar-track: var(--scrollbar-track-dark);
            }
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        #container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background-color: var(--ui-bg-color);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 320px;
            font-size: 14px;
            max-height: calc(100vh - 30px); /* UIの最大高さを設定 */
            overflow-y: auto; /* 内容がはみ出た場合にスクロール */
        }
        
        /* スクロールバーのデザイン */
        #ui::-webkit-scrollbar { width: 8px; }
        #ui::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        #ui::-webkit-scrollbar-thumb:hover { background: var(--accent-color); }

        #hideUiBtn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            color: var(--text-color);
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        #hideUiBtn:hover { opacity: 1; }
        #hideUiBtn svg { width: 16px; height: 16px; }

        #showUiBtn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 11;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            background-color: var(--ui-bg-color);
            backdrop-filter: blur(5px);
            color: var(--text-color);
            border-radius: 8px;
            cursor: pointer;
            display: none; /* 初期状態は非表示 */
        }
        
        #dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        #dropzone svg {
            width: 32px;
            height: 32px;
            opacity: 0.7;
        }
        #dropzone p { margin: 0; }
        #dropzone.dragover { background-color: rgba(3, 169, 244, 0.2); }
        #fileInput { display: none; }
        
        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .control-group label { white-space: nowrap; }

        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(20px); }
        
        input[type="range"] { flex-grow: 1; }
        
        button {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            background-color: var(--button-bg);
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        button:hover { background-color: var(--button-hover-bg); }
        button svg { width: 16px; height: 16px; }
        
        #deleteModelBtn {
            width: 100%;
            padding: 8px;
            background-color: var(--delete-button-bg);
            color: white;
            border: none;
            font-weight: bold;
        }
        #deleteModelBtn:hover { background-color: var(--delete-button-hover-bg); }
        
        #teleport-section { padding-top: 10px; border-top: 1px solid var(--border-color); }
        #teleport-section h3 { margin: 0 0 8px 0; font-size: 1em; }
        .teleport-controls { display: flex; gap: 5px; align-items: center; }
        .teleport-controls input[type="number"] {
            width: 55px; padding: 4px; background-color: var(--bg-color); color: var(--text-color);
            border: 1px solid var(--border-color); border-radius: 4px; -moz-appearance: textfield;
        }
        .teleport-controls input[type="number"]::-webkit-outer-spin-button,
        .teleport-controls input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .teleport-controls button { flex-grow: 1; }

        #info-panel { padding-top: 10px; border-top: 1px solid var(--border-color); }
        #info-panel h3 { margin: 0 0 8px 0; font-size: 1em; }
        #info-panel p { margin: 2px 0; font-size: 0.9em; line-height: 1.5; }
        
        #stats-js { position: absolute; top: 15px; right: 15px; }
    </style>
</head>
<body>
    <div id="container"></div>

    <button id="showUiBtn">UIを表示</button>

    <div id="ui">
        <button id="hideUiBtn" title="UIを非表示">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16">
                <path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/>
            </svg>
        </button>
        <div id="dropzone">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-upload" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M4.406 1.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10a.5.5 0 0 1 0-1h2.688C13.979 10 15 8.988 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-2.941 1.1c-.757.652-1.153 1.438-1.153 2.055v.448l-.445.049C2.064 4.805 1 5.952 1 7.318 1 8.785 2.23 10 3.781 10H6a.5.5 0 0 1 0 1H3.781C1.708 11 0 9.366 0 7.318c0-1.763 1.266-3.223 2.942-3.593.143-.863.698-1.723 1.464-2.383"/>
                <path fill-rule="evenodd" d="M7.646 4.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V14.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708z"/>
            </svg>
            <p>ここにファイルをドラッグ＆ドロップ</p>
            <button id="selectFileBtn">またはファイルを選択</button>
            <input type="file" id="fileInput">
        </div>
        
        <div class="control-group">
            <label for="showEdges">エッジ表示</label>
            <label class="switch"><input type="checkbox" id="showEdges"><span class="slider"></span></label>
        </div>
        
        <div class="control-group">
            <label for="showAxes">座標軸表示</label>
            <label class="switch"><input type="checkbox" id="showAxes" checked><span class="slider"></span></label>
        </div>

        <div class="control-group">
            <label for="showGrid">地面グリッド表示</label>
            <label class="switch"><input type="checkbox" id="showGrid" checked><span class="slider"></span></label>
        </div>

        <div class="control-group">
            <label for="modelScale">モデルサイズ</label>
            <input type="range" id="modelScale" min="0.1" max="5" step="0.05" value="1">
            <button id="resetScale" title="サイズをリセット">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-repeat" viewBox="0 0 16 16">
                    <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41m-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9"/>
                    <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5 5 0 0 0 8 3M3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9z"/>
                </svg>
            </button>
        </div>

        <button id="deleteModelBtn" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
            </svg>
            モデルを削除
        </button>
        
        <div id="teleport-section">
            <h3>テレポート</h3>
            <div class="teleport-controls">
                <input type="number" id="teleportX" placeholder="X">
                <input type="number" id="teleportY" placeholder="Y">
                <input type="number" id="teleportZ" placeholder="Z">
                <button id="teleportBtn">移動</button>
            </div>
        </div>

        <div id="info-panel">
            <h3>情報</h3>
            <p id="coords-output">カメラ座標: X:0 Y:0 Z:0</p>
            <div id="stats-output">
                <p id="info-text">モデルを読み込んでください</p>
            </div>
        </div>
    </div>
    
    <div id="stats-js"></div>

    <!-- ライブラリ -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- メインのJSコード -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import Stats from 'three/addons/libs/stats.module.js';

        let scene, camera, renderer, controls, stats, axesHelper, gridHelper;
        let modelWrapper;
        let fileInfo = { name: '', size: 0 };
        let fullGltfData;
        let initialModelSize = 0;
        let initialCameraDistance = 0;

        const container = document.getElementById('container');
        const uiPanel = document.getElementById('ui');
        const hideUiBtn = document.getElementById('hideUiBtn');
        const showUiBtn = document.getElementById('showUiBtn');
        const statsJsPanel = document.getElementById('stats-js');
        const fileInput = document.getElementById('fileInput');
        const dropzone = document.getElementById('dropzone');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const showEdgesCheckbox = document.getElementById('showEdges');
        const showAxesCheckbox = document.getElementById('showAxes');
        const showGridCheckbox = document.getElementById('showGrid');
        const statsOutput = document.getElementById('stats-output');
        const coordsOutput = document.getElementById('coords-output');
        const scaleSlider = document.getElementById('modelScale');
        const resetScaleBtn = document.getElementById('resetScale');
        const deleteModelBtn = document.getElementById('deleteModelBtn');
        const teleportXInput = document.getElementById('teleportX');
        const teleportYInput = document.getElementById('teleportY');
        const teleportZInput = document.getElementById('teleportZ');
        const teleportBtn = document.getElementById('teleportBtn');


        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            const bodyStyles = getComputedStyle(document.body);
            scene.background = new THREE.Color(bodyStyles.getPropertyValue('--bg-color'));

            // Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(10, 10, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Stats.js
            stats = new Stats();
            statsJsPanel.appendChild(stats.dom);

            // Helpers
            gridHelper = new THREE.GridHelper(10000, 10000);
            scene.add(gridHelper);
            axesHelper = new THREE.AxesHelper(1000);
            scene.add(axesHelper);
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            fileInput.addEventListener('change', handleFileSelect);
            dropzone.addEventListener('dragover', handleDragOver);
            dropzone.addEventListener('dragleave', handleDragLeave);
            dropzone.addEventListener('drop', handleFileDrop);
            selectFileBtn.addEventListener('click', (e) => { e.stopPropagation(); fileInput.click(); });
            showEdgesCheckbox.addEventListener('change', toggleEdges);
            showAxesCheckbox.addEventListener('change', toggleAxesHelper);
            showGridCheckbox.addEventListener('change', toggleGridHelper);
            scaleSlider.addEventListener('input', handleScaleChange);
            resetScaleBtn.addEventListener('click', resetScale);
            deleteModelBtn.addEventListener('click', cleanScene);
            teleportBtn.addEventListener('click', handleTeleport);
            hideUiBtn.addEventListener('click', () => toggleUi(false));
            showUiBtn.addEventListener('click', () => toggleUi(true));

            // Theme change listener
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                const newColorScheme = e.matches ? "dark" : "light";
                const newBgColor = getComputedStyle(document.body).getPropertyValue(`--bg-color-${newColorScheme}`);
                scene.background = new THREE.Color(newBgColor);
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            stats.update();
            const camPos = camera.position;
            coordsOutput.textContent = `カメラ座標: X:${camPos.x.toFixed(2)} Y:${camPos.y.toFixed(2)} Z:${camPos.z.toFixed(2)}`;
            renderer.render(scene, camera);
        }

        // --- File Handling ---
        function handleFileSelect(event) { loadFile(event.target.files[0]); }
        function handleDragOver(event) { event.preventDefault(); dropzone.classList.add('dragover'); }
        function handleDragLeave(event) { event.preventDefault(); dropzone.classList.remove('dragover'); }
        function handleFileDrop(event) {
            event.preventDefault();
            dropzone.classList.remove('dragover');
            if (event.dataTransfer.files.length > 0) { loadFile(event.dataTransfer.files[0]); }
        }
        
        async function loadFile(file) {
            if (!file) return;
            cleanScene();
            fileInfo = { name: file.name, size: file.size };
            statsOutput.innerHTML = '<p>読み込み中...</p>';
            const extension = file.name.split('.').pop().toLowerCase();
            if (extension === 'zip') { await handleZipFile(file); } 
            else { const url = URL.createObjectURL(file); loadModel(url, extension); }
        }

        async function handleZipFile(file) {
            const jszip = new JSZip();
            const zip = await jszip.loadAsync(file);
            const objectURLs = {};
            const filesToLoad = [];
            for (const filename in zip.files) {
                if (!zip.files[filename].dir) { filesToLoad.push({ filename, promise: zip.files[filename].async('blob') }); }
            }
            const blobs = await Promise.all(filesToLoad.map(f => f.promise));
            filesToLoad.forEach((f, i) => { objectURLs[f.filename] = URL.createObjectURL(blobs[i]); });
            const manager = new THREE.LoadingManager();
            manager.setURLModifier((url) => {
                const found = Object.keys(objectURLs).find(key => key.endsWith(url.split('/').pop()));
                return objectURLs[found] || url;
            });
            const modelFile = Object.keys(objectURLs).find(f => /\.(gltf|glb|obj|fbx|stl)$/i.test(f));
            if (modelFile) { loadModel(objectURLs[modelFile], modelFile.split('.').pop().toLowerCase(), manager); } 
            else { statsOutput.innerHTML = '<p>ZIP内に対応モデルが見つかりません。</p>'; }
        }

        function loadModel(url, extension, manager = new THREE.LoadingManager()) {
            let loader;
            switch (extension) {
                case 'glb': case 'gltf': loader = new GLTFLoader(manager); break;
                case 'obj': loader = new OBJLoader(manager); break;
                case 'fbx': loader = new FBXLoader(manager); break;
                case 'stl': loader = new STLLoader(manager); break;
                default: statsOutput.innerHTML = `<p>非対応の形式です: .${extension}</p>`; return;
            }
            loader.load(url, (loadedObject) => {
                let actualModel;
                if (extension === 'gltf' || extension === 'glb') {
                    fullGltfData = loadedObject;
                    actualModel = loadedObject.scene;
                } else if (extension === 'stl') {
                    actualModel = new THREE.Mesh(loadedObject, new THREE.MeshPhongMaterial({ color: 0xaaaaaa, specular: 0x111111, shininess: 200 }));
                } else {
                    actualModel = loadedObject;
                }
                modelWrapper = new THREE.Group();
                scene.add(modelWrapper);
                fitAndCenterObject(actualModel, modelWrapper);
                updateStats();
                if (showEdgesCheckbox.checked) { createEdges(actualModel); }
                deleteModelBtn.style.display = 'inline-flex';
            }, 
            (xhr) => { if (xhr.lengthComputable) statsOutput.innerHTML = `<p>読み込み中: ${(xhr.loaded / xhr.total * 100).toFixed(0)}%</p>`; },
            (error) => { console.error(error); statsOutput.innerHTML = '<p>モデルの読み込みに失敗しました。</p>'; }
            );
        }
        
        function cleanScene() {
            deleteModelBtn.style.display = 'none';
            if (modelWrapper) {
                scene.remove(modelWrapper);
                modelWrapper.traverse(object => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (Array.isArray(object.material)) {
                            object.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else if (object.material) {
                            if (object.material.map) object.material.map.dispose();
                            object.material.dispose();
                        }
                    }
                });
                modelWrapper = null;
            }
            controls.minDistance = 0;
            controls.maxDistance = Infinity;
            initialModelSize = 0;
            initialCameraDistance = 0;
            fullGltfData = null;
            showEdgesCheckbox.checked = false;
            resetScale();
            statsOutput.innerHTML = '<p id="info-text">モデルを読み込んでください</p>';
        }

        function fitAndCenterObject(object, wrapper) {
            wrapper.add(object);
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            object.position.x -= center.x;
            object.position.y -= box.min.y;
            object.position.z -= center.z;
            const finalBox = new THREE.Box3().setFromObject(wrapper);
            const size = finalBox.getSize(new THREE.Vector3());
            const wrapperCenter = finalBox.getCenter(new THREE.Vector3());
            const maxSize = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = 1.5 * Math.max(fitHeightDistance, fitWidthDistance);
            initialModelSize = maxSize;
            initialCameraDistance = distance;
            controls.target.copy(wrapperCenter);
            camera.near = distance / 100;
            camera.far = distance * 100;
            camera.updateProjectionMatrix();
            camera.position.copy(wrapperCenter);
            camera.position.z += distance;
            controls.minDistance = initialModelSize * 0.1;
            controls.maxDistance = initialCameraDistance * 50;
            controls.update();
        }

        // --- UI Functions ---
        function updateStats() {
            if (!modelWrapper) return;
            const stats = { vertices: 0, triangles: 0, objects: 0, lights: 0, cameras: 0, geometries: new Set(), materials: new Set(), textures: new Set() };
            modelWrapper.children[0].traverse((child) => {
                if (child.isMesh) {
                    stats.objects++;
                    if (child.geometry) {
                        stats.geometries.add(child.geometry.uuid);
                        stats.vertices += child.geometry.attributes.position.count;
                        stats.triangles += (child.geometry.index) ? child.geometry.index.count / 3 : child.geometry.attributes.position.count / 3;
                    }
                    if (Array.isArray(child.material)) { child.material.forEach(m => collectMaterialInfo(m, stats)); } 
                    else if (child.material) { collectMaterialInfo(child.material, stats); }
                } else if (child.isLight) { stats.lights++; } 
                  else if (child.isCamera) { stats.cameras++; }
            });
            const animationsCount = fullGltfData?.animations?.length || 0;
            const size = new THREE.Box3().setFromObject(modelWrapper).getSize(new THREE.Vector3());
            statsOutput.innerHTML = `
                <h3>モデル情報</h3>
                <p><strong>ファイル名:</strong> ${fileInfo.name}</p>
                <p><strong>ファイルサイズ:</strong> ${(fileInfo.size / 1024 / 1024).toFixed(2)} MB</p>
                <p><strong>寸法 (W/H/D):</strong> ${size.x.toFixed(2)} / ${size.y.toFixed(2)} / ${size.z.toFixed(2)}</p>
                <hr style="border: none; border-top: 1px solid var(--border-color); margin: 5px 0;">
                <p><strong>頂点数:</strong> ${stats.vertices.toLocaleString()}</p>
                <p><strong>三角形数:</strong> ${Math.floor(stats.triangles).toLocaleString()}</p>
                <p><strong>オブジェクト数:</strong> ${stats.objects.toLocaleString()}</p>
                <p><strong>ジオメトリ数:</strong> ${stats.geometries.size.toLocaleString()}</p>
                <p><strong>マテリアル数:</strong> ${stats.materials.size.toLocaleString()}</p>
                <p><strong>テクスチャ数:</strong> ${stats.textures.size.toLocaleString()}</p>
                <p><strong>アニメーション数:</strong> ${animationsCount}</p>
                <p><strong>ライト数:</strong> ${stats.lights}</p>
                <p><strong>カメラ数:</strong> ${stats.cameras}</p>
            `;
        }
        
        function collectMaterialInfo(material, stats) {
            stats.materials.add(material.uuid);
            for (const key in material) { if (material[key] instanceof THREE.Texture) { stats.textures.add(material[key].uuid); } }
        }

        function handleScaleChange(e) {
            if (modelWrapper) {
                const scale = parseFloat(e.target.value);
                modelWrapper.scale.set(scale, scale, scale);
                if (initialModelSize > 0 && initialCameraDistance > 0) {
                    controls.minDistance = initialModelSize * 0.1 * scale;
                    controls.maxDistance = initialCameraDistance * 50 * scale;
                }
                updateStats();
            }
        }
        
        function resetScale() {
            if (modelWrapper) {
                modelWrapper.scale.set(1, 1, 1);
                if (initialModelSize > 0 && initialCameraDistance > 0) {
                    controls.minDistance = initialModelSize * 0.1;
                    controls.maxDistance = initialCameraDistance * 50;
                }
                updateStats();
            }
            scaleSlider.value = 1;
        }

        function toggleEdges() {
            if (!modelWrapper) return;
            const actualModel = modelWrapper.children[0];
            if (showEdgesCheckbox.checked) { createEdges(actualModel); } 
            else { removeEdges(actualModel); }
        }
        
        function toggleAxesHelper() { axesHelper.visible = showAxesCheckbox.checked; }
        function toggleGridHelper() { gridHelper.visible = showGridCheckbox.checked; }
        
        function toggleUi(show) {
            uiPanel.style.display = show ? 'flex' : 'none';
            statsJsPanel.style.display = show ? 'block' : 'none';
            showUiBtn.style.display = show ? 'none' : 'block';
        }

        function handleTeleport() {
            const x = parseFloat(teleportXInput.value);
            const y = parseFloat(teleportYInput.value);
            const z = parseFloat(teleportZInput.value);
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) { camera.position.set(x, y, z); controls.update(); } 
            else { alert('有効な数値をすべての座標に入力してください。'); }
        }

        function createEdges(object) {
            object.traverse((child) => {
                if (child.isMesh && !child.children.some(c => c.userData.isEdge)) {
                    const edges = new THREE.EdgesGeometry(child.geometry, 15);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x03a9f4, transparent: true, opacity: 0.8 }));
                    line.userData.isEdge = true;
                    child.add(line);
                }
            });
        }

        function removeEdges(object) {
            const edgesToRemove = [];
            object.traverse(child => {
                child.children.forEach(grandchild => { if (grandchild.userData.isEdge) edgesToRemove.push(grandchild); });
            });
            edgesToRemove.forEach(edge => {
                edge.parent.remove(edge);
                edge.geometry.dispose();
                edge.material.dispose();
            });
        }
    </script>
</body>
</html>
